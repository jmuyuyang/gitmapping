{
  "author": {
    "name": "Eirik Albrigtsen",
    "email": "analsandblaster@gmail.com"
  },
  "name": "logule",
  "description": "A multi-transport, peer-dependent logging library",
  "version": "2.0.0",
  "repository": {
    "type": "git",
    "url": "git://github.com/clux/logule.git"
  },
  "main": "lib/logule.js",
  "engines": {
    "node": ">=0.8"
  },
  "keywords": [
    "stdout",
    "emitter",
    "json",
    "file",
    "branch",
    "filtration",
    "configurable"
  ],
  "scripts": {
    "test": "tap ./test"
  },
  "dependencies": {
    "dye": "~0.1.0",
    "autonomy": "~0.5",
    "subset": "~0.1.3",
    "confortable": "~0.2.0",
    "typr": "~0.2.0"
  },
  "devDependencies": {
    "tap": "~0.3.1"
  },
  "bugs": {
    "url": "http://github.com/clux/logule/issues"
  },
  "license": "MIT",
  "readme": "# Logule [![Build Status](https://secure.travis-ci.org/clux/logule.png)](http://travis-ci.org/clux/logule)\n\nLogule is a pretty, but heavily configurable logging utility for nodejs. It allows multiple transports (stdout + JSON filestream + emitted logs) as well as being configurable per user, per app and per module via localized config files.\n\n![simple output!](https://github.com/clux/logule/raw/master/imgs/outputsimple.png)\n\n## Key Design Goal\nLogging is a simple yet deceptively hairy problem. You don't want foreign modules to spam your app with needless messages, but you also don't want them to not say anything if you are passing bad stuff to them either. You want logs to look pretty, but you also want everyone else's logs to look like yours, and if that's not possible, you want to turn their logs off.\n\nWhat you really want, is not simply configurability, but a *hierarchy of configurability and suppression*. You want to be able to:\n\n- Mute specific log levels globablly\n- Mute non-fatal info from certain branches of code\n- Mute chatty modules\n- Unmute new/experimental modules during development\n\nas well as being able to configure *how* your:\n\n- module logs by default\n- app logs by default (perhaps overriding individual module defaults)\n- apps log by default (by providing sensible overall configs)\n\nManipulating these settings should be super easy, as it's most useful during development and debug sessions where time is of the essence.\n\nFinally, you should be able to get trace/debug messages from a module that's not behaving correctly, without spamming the shit out of people not using logule!\n\nLogule strives to adhere these goals and beyond that has since 1.0  maintained a stable API. Features so far has been greatly improved via issues/pull requests contributions, so please follow this path if there is anything you feel deserves attention.\n\n## Index\n\n* [Basic Usage](#basic-usage)\n* [Namespaces](#namespaces)\n* [Subs](#subs)\n* [Logging Methods](#logging-methods)\n  * [debug()](#debug)\n  * [line()](#line)\n  * [trace()](#trace)\n  * [info()](#info)\n  * [warn()](#warn)\n  * [error()](#error)\n  * [zalgo()](#zalgo)\n  * [get()](#getlevel--namespace)\n* [Mute API](#mute-api)\n  * [mute()](#mute)\n  * [unmute()](#unmute)\n  * [muteOnly()](#muteonly)\n  * [unmuteOnly()](#unmuteonly)\n* [Configuration](#configuration)\n  * [Transports](#transports)\n    * [stdout](#stdout)\n    * [Emitter](#emitter)\n    * [Filestream](#filestream)\n  * [Style & Formatting](#style--formatting)\n  * [Timestamps](#timestamps)\n  * [Global Suppression](#global-suppression)\n* [Branch Based Filtration](#branch-based-filtration)\n  * [Filtering Branches](#filtering-branches)\n  * [Muting Chatty Modules](#muting-chatty-modules)\n  * [Unmuting New Modules](#unmuting-new-modules)\n* [Colors](#colors)\n* [npm Usage](#npm-usage)\n* [Installation](#installation)\n* [Running Tests](#running-tests)\n* [License](#license)\n\n## Basic Usage\nFile scope usage; pass down the `module` object at the start.\n\n```js\nvar log = require('logule').init(module);\nlog.error(\"this is an error message\")\nlog.warn(\"<- heed this\")\nlog.info(\"info %s %d %j\", \"message\", 1, {a: 2})\nlog.debug(\"this message has to be turned on\");\n```\n\n![simple output!](https://github.com/clux/logule/raw/master/imgs/outputsimple.png)\n\n## Namespaces\nTo add a namespace to this module, add a second parameter to `init()`.\n\n```js\nlog = require('logule').init(module, 'BUILD');\nlog.trace(\"Trying to compile client.js\");\nlog.error(\"Failed\");\n```\n\n**Namespaces inherit from the call tree in order of registration.** If your entry point required the 'BUILD' module, and this has a namespace, then 'BUILD' becomes the next namespace in the chain. When printing to `stdout` there's a default limit of nesting printed out of 3.\n\n![one namespace output!](https://github.com/clux/logule/raw/master/imgs/output.png)\n\nIn this case, the entry point that required 'BUILD' had no namespace. See [Filtering Branches](#filtering-branches) for a more detailed example of how namespaces nest.\n\n## Subs\nSubs are copies of logger instances that do not save settings to the call tree.\nThis allows you to have muted/unmuted logger instances inside a particular file without inadvertently muting or unmuting levels (resp.) from dependent modules.\n\n```js\nvar log = require('logule').init(module, 'myFile');\nvar spammy = log.sub('spammy').unmute('trace');\n// pass spammy logger to external/internal code\n```\n\nA `log.sub()` will maintain the the original namespaces and mute settings of `log` as well as config suppressions (so unmute does not override config `suppress`). It can also optionally append one extra namespace to the ones existing, in this case, 'external' will be appended.\n\nSee [Filtering Branches](#filtering-branches) for a more detailed example of how subs are used.\n\n## Logging Methods\nThere are 7 log levels (and one method getter) available available on `log`:\n\n### debug()\nFor debug info to help out during bad times. Suppressed by default, safe to leave in.\n\n### line()\nFor temporary debug messages that you sprinkle liberally throughout your nasty functions.\nPrepends filename.js:lineNum to the message.\nNote these fetch new stacks at each call and are not meant to be used in production. They are always shown in the default config, so don't leave these in code.\n\n```js\nvar log = require('logule').init(module, 'broken');\nlog.debug('dumping lines to console');\nlog.line();\nlog.line();\n```\n\n![line output!](https://github.com/clux/logule/raw/master/imgs/line.png)\n\n### trace()\nFor info messages that are too common to see all the time. Suppressed by default, safe to leave in.\n\n### info()\nFor messages that show events/standard progressions.\nThese will be shown by default in any module you embed logule in when installed on a new box (i.e. without a custom config).\nEnsure you're not talking when you should not need to - consider `trace.\n\n### warn()\nFor warnings. Shown by default.\n\n### error()\nFor errors. Shown by default in bold. Not meant to handle Error objects, just the logging please.\n\n### zalgo()\n[H̸̡̪̯ͨ͊̽̅̾̎Ȩ̬̩̾͛ͪ̈́̀́͘ ̶̧̨̱̹̭̯ͧ̾ͬC̷̙̲̝͖ͭ̏ͥͮ͟Oͮ͏̮̪̝͍M̲̖͊̒ͪͩͬ̚̚͜Ȇ̴̟̟͙̞ͩ͌͝S̨̥̫͎̭ͯ̿̔̀ͅ](https://github.com/clux/dye#zalgo)\n\n```js\nlog.zalgo('core melting')\n```\n\n![zalgo output!](https://github.com/clux/logule/raw/master/imgs/zalgo.png)\n\nDisclaimer; this is mostly for fun. Find your own use case or suppress it. Note that zalgolization is only applied to stdout, not to the `filestream` or `emitter` transports.\n\n\n### get(level [, namespace])\nLevels can be retrieved as single functions that do not chain by using this method.\nUseful if you have a debug module that only needs `log.debug`, so you can pass down a perhaps namespaced function to it.\n\n```js\nvar dbg = log.get('debug');\ndbg(\"works like log.debug - but this function does not chain and expose other methods\");\n```\n\nNote that `get()` result obeys the mute API and config suppression entirely like the individual level methods.\n\n*Warning:* while you simulate this with `log.debug.bind(log)`, this would chain and allow modules to break out of the constricted environment.\n\n## Mute API\nThese methods are shortcuts for modifying the private list of muted levels.\nMuting affects by default `stdout` and `filestream`, but the config allows changing this to any combination of transports being affected.\n\n### mute()\nSuppress logs for passed in methods.\n\n```js\nlog.mute('warn', 'info');\nlog.info('muted').warn('muted').error('works');\n```\n\n### unmute()\nUnmutes logs for passed in methods.\n\n```js\nlog.mute('warn');\nvar l2 = log.sub('forModuleX').unmute('warn', 'info');\nlog.warn('muted');\nl2.warn('works!');\n```\n\nNB: unmute does not override config suppression. It has lower precedence.\n\n### muteOnly()\nA convenience for muting all levels passed in, and unmuting all others.\n\n```js\nlog.muteOnly('debug', 'trace'); // unmutes everything except trace & debug\nlog.muteOnly(); // muteOnly nothing === unmute everything\n```\n\n### unmuteOnly()\nA convenience for unmuting all levels passed in, and muting the others.\n\n```js\nlog.unmuteOnly('error'); // mutes everything except error\nlog.unmuteOnly(); // unmuteOnly nothing === mute everything\n```\n\n## Configuration\nConfiguration of colors, style, date formatting, transports, setting mutability and global suppression levels are done via via config files. The [default configuration file](https://github.com/clux/logule/blob/master/.logule.json) results in output looking like the images herein.\n\nConfigs are located via the [confortable](https://github.com/clux/confortable) module. This module performs priority based config searches. In particular, it is used here with the following path priorities:\n\n- 1. execution directory\n- 2a). if (`execDir` outside `$HOME`) `$HOME`\n- 2b). if (`execDir` inside  `$HOME`) Up to and including `$HOME` in `..` increments\n- 3. directory of `module.parent`\n\nStep 3 enables modules to bundle their own default config which can be overriden by apps by utilizing step 2.\n\nThe found config file is merged one level deep with the default config, so you don't have to include more in your config than what you disagree with.\n\n### Transports\nLogule supports 3 transports: `stdout`, `filestream` and `emitter`.\nThese all have similar options in the config, but by default only `stdout` is enabled.\n\n**NB: Logule does not strip colors.** If you log pre-colored strings, those colors will show up in the other transports as well!\n\nAll transports have the following options:\n\n- `suppress`  - list of levels to globally suppress from the transport\n- `mutable`   - a boolean to indicate whether the mute API affects the transport\n- `timestamp` - an object/string to indicate timesta\n\n#### stdout\nAll logs are by default written directly to `process.stdout`\n\n#### Emitter\nIf `emitter` has an `enabled` attribute set to `true`, logule will expose an `EventEmitter` instance on `require('logule').stream`.\n\nThen you can listen to `\"log\"` events:\n\n```js\nvar logule = require('logule');\nvar e = logule.emitter;\nvar log = logule.init(module);\ne.on('log', function (obj) {\n  // plain replacement logging\n  console.log(obj.time.valueOf() + ' - ' + obj.level + ' - ' + obj.message);\n});\n```\nThe types of the keys in `obj` are as follows:\n\n```js\n{\n  time : Date\n  level: String\n  namespaces : Array of Strings\n  message : String\n}\n```\n\nIn the case of level being `'line'`, a `line` key is also available with the short location identifier string `line()` typically outputs.\n\n#### Filestream\nIf `filestream` has a `file` attribute filled in (with a cwd relative path), this file will be appended to with JSON log messages (one message per line - so JSON.parse forEach line in file.split('\\n') will work).\n\nBy default the individual JSON messages use the current format:\n\n```js\n{\n  \"time\": \"2012-11-08T11:08:25.092Z\",\n  \"level\": \"error\",\n  \"namespaces\": [\"build\"],\n  \"message\": \"message part, without stdout formatting\"\n}\n```\n\nWhere the `time` value may differ depending on the `timestamp` config option.\n\nNB: A `\"line\"` key is present if level is `\"line\"` like in the EventEmitter.\n\n### Style & Formatting\nThe [first four blocks](https://github.com/clux/logule/blob/master/.logule.json#L2-22) in the default config describes the default style set used by the `stdout` transport and are all of the form `levelName : fn` where `fn` is any function in the module [dye](https://github.com/clux/dye). Functions can even be composed by delimiting them with a dot; e.g. `bold.blue`.\n\nThe `delimiters` object contains the subtle default styling of the delimiters joining the optional timestamp, the log level, the optional namespaces and the message.\n\nThe `levels` object contain the styling for the log levels. By default we only apply `bold` to the critical messages.\n\nThe `messages` object contain styling fot the messages (i.e. the result of `util.format(args..)`). By default only zalgo gets message level formatting.\n\nThe `colors` object contain the misc. styling used:\n\n- `namespace` - the default blue namespaces\n- `timestamp` - the default grey optional timestamp\n- `callsite`  - the default green file.js:line prefix added by .line()\n\n\nNB: Levels already listed in the `delimiters`, `levels` or `messages` objects, can be disabled by overriding them in your personal/module's config with the value of `\"none\"`.\n\n### Timestamps\nTimestamps can be configured via the \"timestamp\" key in the config which is overloaded as follows:\n\n- `\"none\"`     - nothing prepended; log output starts at type, e.g. the `INFO` part\n- `precision`  - prepends HH:MM:SS:MSS + delimiter via above + padded `getMilliseconds`\n- `dateMethod` - prepends the result of any custom method on `Date.prototype`\n- `object`     - full customization mode\n\nExample of using the custom mode:\n\n```js\n\"timestamp\": {\n  \"date\"      : true,\n  \"reverse\"   : false,\n  \"delimiter\" : \"-\",\n  \"precise\"   : false\n}\n```\n\nThis prepends the date, in the form YYYY-MM-DD (i.e. normal non-reversed european style), and adds the timestamp after the date without precision (i.e. just `toLocaleTimeString`).\n\nMost sensible methods on `Date.prototype` are:\n\n- `toJSON` - default for file\n- `valueOf`\n- `toLocaleTimeString` - default for stdout\n- `toGMTString`\n\nNote that the first two can be perfectly serialized/deserialized with `Date.parse` and are thusly a good format for the filestream JSON transport.\n\n### Global Suppression\nSet the `suppress` flag to globally turn all listed log methods into chaining no-ops.\nAlternatively list the exceptions under `allow` instead if you like to suppress most levels.\nSee the [Branch based filtration](#branch-based-filtration) section for more granular control.\nBy default, `trace` and `debug` messages are suppressed.\n\n\n## Branch Based Filtration\nControlling global levels is done via config files, but the levels not globally suppressed therein can temporarily muted/unmuted at any branch point and these settings will propagate down the call tree.\n\n**NB: The following techniques require your disired transport(s) to be `mutable` in the config.**\n\n### Filtering Branches\nTo get the most out of call tree filtration consider the following example of an application structure:\n\n```\na.js\n└──┬b.js\n   └───c.js\n```\n\nWhen just using mute/unmute on an instance returned directly by `init()` logule will remember the call tree and apply the same rules to the ones further down the tree by default:\n\n```js\n// a.js\nvar l = require('logule').init(module, 'app').mute('info');\nvar b = require('./b');\n\n// b.js\nvar l = require('logule').init(module);\nvar c = require('./c');\nl.info('muted');\nl.unmute('info');\nl.info('works');\n\n// c.js\nvar l = require('logule').init(module, 'leaf');\nl.info('works');\n```\n\nWith the following code, `a.js` sets the an app default of _no info messages_, which is overridden by `b.js`, so the unmute propagates to `c.js`. Note that the `app` namespace set in `a.js` propagates down to both `b.js` and `c.js`, but `c.js` will show two namespaces: `app` and `leaf` provided the config setting `nesting >= 2`.\n\nNote that any `mute`/`unmute` calls to a `sub()` does not propagate to other files:\n\n```js\n// a.js as above\n// b.js\nvar l = require('logule').init(module).sub().unmute('info');\nl.info('works');\n\n// c.js\nvar l = require('logule').init(module);\nl.info('still muted');\n```\n\nIn short tree based log levels is the safe, *overridable version* of log levels.\nTo enforce strict suppression of certain levels, the config file is the way to go.\n\n### Muting Chatty Modules\nSay you want to mute warnings in the file `c.js` above. If you own the file, you easily just edit the first line to be:\n\n```js\n// c.js\nvar l = require('logule').init(module).mute('warn', 'info');\n```\n\nHowever, if you don't own the file, perhaps it's deep down in the npm hierarchy for instance, you can propagate more simply from `b.js`.\n\n```js\n// b.js\nvar l = require('logule').init(module).mute('warn', 'info').sub().unmute('warn', 'info');\nvar c = require('./c');\nl.warn('unmuted, but down the call tree it is muted');\n```\n\nHere we mute main logger from `b.js` (the one from `init`), but unmute a `sub` that will be used inside this file to preserve the same behaviour inside `b.js` only.\n\n### Unmuting New Modules\nEssentially the reverse process of [Muting chatty modules](#muting-chatty-modules), there are two cases, you own the file c.js (modify imports line to mute it):\n\n```js\n// c.js\nvar l = require('logule').init(module, 'leaf').unmute('info');\nl.info('works');\n```\n\nOr if you don't own the file (so unmute above in the hierarchy):\n\n```js\n// b.js\nvar l = require('logule').init(module).unmute('info').sub().mute('info');\nl.info('works');\n```\n\nThis preserves muting of `b.js`, but opens up for its descendants.\n\n## Colors\nThe ASNI color code wrapping and zalgolizer is provided by [dye](https://github.com/clux/dye), wheras it used to rely on `colors`. Dye does not introduce implicit global dependencies on `String.prototype`, and provides more sensible zalgolizations.\n\n## npm Usage\nWhen logging with `logule >=2` inside an npm published library/executable, the practice is to put `logule` inside `package.json` `peerDependencies` and NOT the normal `dependencies`. This ensures all modules use the same code and thus logule can encapsulate everything needed to process ALL the logs an application uses. Logule's API is stable, so simply restricting to `\"logule\": \"~2\"` will suffice.\n\nIn `\"logule\": \"~1\"`, bundling of separate copies per npm module was the standard and so logule then adopted the method of communicating with other copies via `process.logule` to compensate for not having any one central piece of code where all logs went through. Ultimately, decisions were being made on behalf of the config so this worked well.\n\n## Installation\n\n```bash\n$ npm install logule\n```\n\n## Running tests\nInstall development dependencies\n\n```bash\n$ npm install\n```\n\nRun the tests\n\n```bash\n$ npm test\n```\n\n## License\nMIT-Licensed. See LICENSE file for details.\n",
  "_id": "logule@2.0.0",
  "dist": {
    "shasum": "1d60ac1a26449121f9bda658e215733910ba993c"
  },
  "_from": "logule"
}
